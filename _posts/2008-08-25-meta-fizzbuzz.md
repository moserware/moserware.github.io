---
layout: post
title: "Meta-FizzBuzz"
date: 2008-08-25 06:58:00
updated: 2008-09-01 17:07:22
permalink: /2008/08/meta-fizzbuzz.html
---
By itself, solving the "[FizzBuzz](http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/)" problem won't get you a [new job](http://www.hanselman.com/blog/YouCantTeachHeightMeasuringProgrammerCompetenceViaFizzBuzz.aspx). If it does, you probably wouldn't want that job. It's a [weed out](http://www.answers.com/weed+out&r=67) type of question that [doesn't say much about your skill](http://www.codinghorror.com/blog/archives/000804.html) if you get it right, but it [hurts your credibility as a programmer](http://www.codinghorror.com/blog/archives/000781.html) if you can't do it. It asks:

> Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.

By rearranging the words in the problem statement and adding a few programmer keywords, you can create this simple [pseudocode solution](http://beta.stackoverflow.com/questions/437/what-is-your-solution-to-the-fizzbuzz-problem#856 "Inspired by deuseldorf's solution on the beta StackOverflow site"):

<pre style="font-family:consolas, courier new, courier, monospace;">
<span style="color:#0000ff;">for every</span> number <span style="color:#0000ff;">from</span> 1 <span style="color:#0000ff;">to</span> 100
  <span style="color:#0000ff;">if</span> the number <span style="color:#0000ff;">is</span> a multiple of 3 <span style="color:#0000ff;">and</span> it <span style="color:#0000ff;">is</span> a multiple of 5 <span style="color:#0000ff;">then</span>
    <span style="color:#0000ff;">print</span> <span style="color:#006080;">"FizzBuzz"</span>
  <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> it <span style="color:#0000ff;">is</span> a multiple of 3 <span style="color:#0000ff;">then</span>
    <span style="color:#0000ff;">print</span> <span style="color:#006080;">"Fizz"</span>
  <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> it <span style="color:#0000ff;">is</span> a multiple of 5 <span style="color:#0000ff;">then</span>
    <span style="color:#0000ff;">print</span> <span style="color:#006080;">"Buzz"</span>
  <span style="color:#0000ff;">else</span>
    <span style="color:#0000ff;">print</span> the number
</pre>

See? Simple and boring.

But what if the bar were raised in the future to be this "Meta-FizzBuzz" problem:

> Create a *language implementation* and write a solution to the FizzBuzz problem using it.

It sounds crazy at first, but if you take it seriously, it is way more interesting than the original FizzBuzz problem. It forces you to have a deeper understanding of languages rather than just getting by with the basics. It also shows that languages are full of many design choices that often have several alternatives.

I decided to create a language implementation that would execute the above "[pseudocode](http://en.wikipedia.org/wiki/Pseudocode)" solution. While working on the implementation, I discovered that needed to handle cases that I hadn't seen in "real" languages:

-   Variables can be prefixed by "the" to make the code more readable. 
-   Instead of having a [modulo operator](http://en.wikipedia.org/wiki/Modulo_operation) (e.g. %), I picked the phrase "is a multiple of". 
-   This language supports the special "it" variable that always refers to the last variable that was explicitly referenced.

These were just arbitrary decisions that I made to make the actual FizzBuzz program easy to read. Even though I'm still in the early stages of the development of [OMeta#](http://www.moserware.com/2008/07/building-object-oriented-parasitic.html), it wasn't too difficult to write a complete "Meta-FizzBuzz" implementation in about 100 lines of code with generous use of comments and whitespace:

<pre  style="font-family:consolas, courier new, courier, monospace;"><span style="color:#0000ff;">ometa</span> <span style="color:#2b91af;">MetaFizzBuzz</span> : <span style="color:#2b91af;">Parser</span> {<br />    <span style="color:#008000;">// Basic literals come first:</span><br /><br />    <span style="color:#008000;">// We override the Parser's version of "Number" which returns a string</span><br />    <span style="color:#008000;">// to instead return the integer value of the string.</span><br />    Number ^= Spaces (<span style="color:#006080;">'+'</span>  <span style="color:#006080;">'-'</span>  Empty):prefix<br />              Digit+:ds -&gt; { <span style="color:#0000ff;">int</span>.Parse(((prefix.Count &gt; 0) ? prefix.As&lt;<span style="color:#0000ff;">string</span>&gt;() : <span style="color:#006080;">""</span>) + ds.As&lt;<span style="color:#0000ff;">string</span>&gt;()) },<br /><br />    <span style="color:#008000;">// Allow literal strings surrounded by quotes (e.g. "FizzBuzz")</span><br />    QuotedString = Spaces <span style="color:#006080;">'"'</span> (~<span style="color:#006080;">'"'</span> :c)*:inner <span style="color:#006080;">'"'</span> -&gt; { inner.Count == 0 ? <span style="color:#006080;">""</span> : inner.As&lt;<span style="color:#0000ff;">string</span>&gt;() },<br /><br />    <span style="color:#008000;">// For more natural sounding code, we allow "the" in front of a variable name.</span><br />    <span style="color:#008000;">// In addition, we keep track of the last variable name used so that we can refer to</span><br />    <span style="color:#008000;">// it as "it" later on.</span><br />    VariableName = ("the"  Empty) Spaces<br />                   FirstAndRest("Letter", "LetterOrDigit"):n<br />                   !{ Set("_it", n.As&lt;<span style="color:#0000ff;">string</span>&gt;()) } -&gt; { n },<br /><br />    <span style="color:#008000;">// Expressions are functions that evaluate to some object.</span><br />    <span style="color:#008000;">// We don't return the value directly since expressions can depend on</span><br />    <span style="color:#008000;">// global variables that could be change while executing.</span><br />    Exp = AndExp<br />         BinExp<br />         NumExp   <br />         QuotedString:qs -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;) (() =&gt; qs.As&lt;<span style="color:#0000ff;">string</span>&gt;()) },<br /><br />    <span style="color:#008000;">// An "and" expression is the highest level of a function that returns</span><br />    <span style="color:#008000;">// a boolean value. This left-recursive definition allows for an arbitrary</span><br />    <span style="color:#008000;">// number of boolean expressions to be and-ed together.</span><br />    AndExp = AndExp:l "and" BoolExp:r -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;)(<br />                                              () =&gt; (<br />                                                     (<span style="color:#0000ff;">bool</span>)l.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()()<br />                                                      &amp;&amp;<br />                                                      (<span style="color:#0000ff;">bool</span>)r.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()()<br />                                                      ))<br />                                         }<br />            BoolExp,<br /><br />    <span style="color:#008000;">// This rule looks at what the expression returns and then tries to</span><br />    <span style="color:#008000;">// convert non-boolean values by declaring that non-zero values and</span><br />    <span style="color:#008000;">// non-empty strings are true and everything else is false.</span><br />    BoolExp = Exp:e -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;)(<br />                           () =&gt; {<br />                                      <span style="color:#0000ff;">object</span> o = e.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()();<br />                                      <span style="color:#0000ff;">return</span> o <span style="color:#0000ff;">is</span> <span style="color:#0000ff;">bool</span> ? (<span style="color:#0000ff;">bool</span>)o<br />                                           : o <span style="color:#0000ff;">is</span> <span style="color:#0000ff;">int</span>  ? ((<span style="color:#0000ff;">int</span>)o) != 0<br />                                           : !<span style="color:#0000ff;">string</span>.IsNullOrEmpty(o as <span style="color:#0000ff;">string</span>) &amp;&amp; (o != <span style="color:#2b91af;">OMetaList</span>&lt;<span style="color:#2b91af;">HostExpression</span>&gt;.Nil);<br />                           })    <br />                       },   <br /><br />    <span style="color:#008000;">// Binary expressions take two arguments (left and right).</span><br />    <span style="color:#008000;">// Here we just have the one that is relevant to FizzBuzz</span><br />    BinExp = NumExp:left<br />             <span style="color:#006080;">"is" </span><span style="color:#006080;">"a"</span> <span style="color:#006080;">"multiple"</span> <span style="color:#006080;">"of"</span><br />             NumExp:right -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;)(<br />                                     () =&gt; {<br />                                               <span style="color:#0000ff;">var</span> l = (<span style="color:#0000ff;">int</span>)left.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()();<br />                                               <span style="color:#0000ff;">var</span> r = (<span style="color:#0000ff;">int</span>)right.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()();<br />                                               <span style="color:#0000ff;">return</span> (l%r) == 0;<br />                                           })<br />                               },              <br /><br />    <span style="color:#008000;">// Number expressions are functions that just return an integer.</span><br />    <span style="color:#008000;">// Note that "it" resolves to the *value* of the variable that was last referenced by name.</span><br />    NumExp = Number:n        -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;) (() =&gt; n.As&lt;<span style="color:#0000ff;">int</span>&gt;()) }   <br />            <span style="color:#006080;">"it"</span>            -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;) (() =&gt; Get&lt;<span style="color:#0000ff;">int</span>&gt;(Get&lt;<span style="color:#0000ff;">string</span>&gt;("_it"))) }<br />            VariableName:vn -&gt; { (<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;) (() =&gt; Get&lt;<span style="color:#0000ff;">int</span>&gt;(vn.As&lt;<span style="color:#0000ff;">string</span>&gt;())) },<br />   <br />    <span style="color:#008000;">// Statements are the things that actually do work in this language.</span><br />    Stmt = <span style="color:#006080;">"print"</span> Exp:e -&gt; { (<span style="color:#2b91af;">Action</span>) (() =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(e.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()()); }) }  <br />          <span style="color:#006080;">"if"</span> AndExp:b <span style="color:#006080;">"then"</span> Stmt:t<br />           (<span style="color:#006080;">"else"</span> Stmt  Empty):f -&gt; { (<span style="color:#2b91af;">Action</span>) (<br />                                            () =&gt; {<br />                                                     <span style="color:#0000ff;">if</span>((<span style="color:#0000ff;">bool</span>)b.As&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#0000ff;">object</span>&gt;&gt;()())<br />                                                       t.As&lt;<span style="color:#2b91af;">Action</span>&gt;()();<br />                                                     <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span>(f.Count &gt; 0)<br />                                                       f.As&lt;<span style="color:#2b91af;">Action</span>&gt;()();<br />                                                  })<br />                                      }<br />         <span style="color:#006080;">"for"</span> <span style="color:#006080;">"every"</span> VariableName:n <span style="color:#006080;">"from"</span><br />           Number:low <span style="color:#006080;">"to"</span> Number:high<br />           Stmt:s -&gt; {  (<span style="color:#2b91af;">Action</span>) (<br />              () =&gt; {<br />               <span style="color:#0000ff;">int</span> lowerBound = low.As&lt;<span style="color:#0000ff;">int</span>&gt;();<br />               <span style="color:#0000ff;">int</span> upperBound = high.As&lt;<span style="color:#0000ff;">int</span>&gt;();          <br />               <span style="color:#0000ff;">string</span> iterationVar = n.As&lt;<span style="color:#0000ff;">string</span>&gt;();<br />               <span style="color:#2b91af;">Action</span> iterationStmt = s.As&lt;<span style="color:#2b91af;">Action</span>&gt;();<br />               <span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i = lowerBound; i &lt;= upperBound; i++)<br />               {<br />                  Set(iterationVar, i);<br />                  iterationStmt();                <br />               }<br />              })<br />         },<br /><br />    <span style="color:#008000;">// A "block" is zero or more statements.</span><br />    Block = Stmt*:s -&gt; { (<span style="color:#2b91af;">Action</span>) (<br />                          () =&gt; {<br />                           <span style="color:#0000ff;">foreach</span>(<span style="color:#0000ff;">var</span> currentStatement <span style="color:#0000ff;">in</span> s)<br />                           {<br />                              currentStatement.As&lt;<span style="color:#2b91af;">Action</span>&gt;()();<br />                           }<br />                          })<br />                         },<br />  <br />    <span style="color:#008000;">// And finally, a "program" is just a series of statements, which is a "block"</span><br />    Program = Block<br />}</pre>

**Full disclosure**: It took some debugging to get this implementation to work right.

If I had been beamed into the future and had to write this solution on a whiteboard, I would have been a bit nervous that I wouldn't have gotten it right and would have taken noticeably more time than I now take to write a FizzBuzz solution.

In order to keep the code size down, I directly execute [the "pseudocode"](http://www.codeplex.com/ometasharp/SourceControl/FileView.aspx?itemId=348120&changeSetId=16572) rather than convert it to an [intermediate tree](http://en.wikipedia.org/wiki/Abstract_syntax_tree). I also simplified things by making all variables in this language global. The [latest version of the source code](http://www.codeplex.com/ometasharp/SourceControl/DirectoryView.aspx?SourcePath=%24%2fometasharp%2ftrunk&changeSetId=16572) has a slightly [more elaborate version of Meta-FizzBuzz](http://www.codeplex.com/ometasharp/SourceControl/FileView.aspx?itemId=347832&changeSetId=16572) that also allows [an alternative pseudocode implementation](http://www.codeplex.com/ometasharp/SourceControl/FileView.aspx?itemId=348135&changeSetId=16572).

The current implementation of [OMeta#](http://www.codeplex.com/ometasharp) uses C# 3.0 as the [host language](http://www.moserware.com/2008/07/building-object-oriented-parasitic.html). This makes everything inside of the { }'s two to three times uglier and larger than it might have been if I had used a more dynamic host language like [JavaScript](http://blogs.msdn.com/deepak/archive/2007/05/02/managed-jscript-is-availaible.aspx), [Python](http://www.codeplex.com/IronPython), [Ruby](http://en.wikipedia.org/wiki/IronRuby), or possibly [C# 4.0](http://blogs.msdn.com/charlie/archive/2008/01/25/future-focus.aspx). As I mentioned in my [last post](http://www.moserware.com/2008/07/building-object-oriented-parasitic.html), my hope is that eventually I'll be able to use clever techniques to make the host code appear more dynamic even though it might need to be strongly typed.

In the end, the Meta-FizzBuzz problem is just a thought experiment to guess what the low bar might look like in the future. That is, a future where it's so easy to create a language that perfectly fits your problem that people actually do. As an industry, we're not there yet, but it's fun to dream of the [STEPS](http://www.vpri.org/pdf/steps_TR-2007-008.pdf) needed to get there.

**Feedback:** What do you think the low bar will be in an upcoming era of [Moore's Law Software](http://www.moserware.com/2008/04/towards-moores-law-software-part-3-of-3.html)? What do you think of the Meta-FizzBuzz problem? Feel free to post your own solution (or outline of a path that you'd take towards a solution) in the comments. Comments are also encouraged about OMeta#'s current syntax in general.